pragma solidity ^0.5.16;
pragma experimental ABIEncoderV2;

import "./MixinResolver.sol";
import "./State.sol";

import "./interfaces/IPerpsInterfacesV2.sol";

contract PerpsStorageV2 is IPerpsStorageV2External, IPerpsStorageV2Internal, IPerpsTypesV2, State {
    /* ========== Events ========== */
    event MarketInitialised(bytes32 marketKey, bytes32 baseAsset);
    event PositionInitialised(bytes32 indexed marketKey, uint id, address account);
    event FundingUpdated(bytes32 indexed marketKey, int funding, uint timestamp);

    /* ========== PUBLIC STATE ========== */
    // storage is split between multiple variables instead of nesting in a single e.g. Market
    // struct so that at some getters are autogenerated and no state remains inaccessible

    mapping(bytes32 => MarketScalars) public marketScalars;
    // getter marketScalars(bytes32)(MarketScalars)

    mapping(bytes32 => FundingEntry) public lastFundingEntry;
    // getter lastFundingEntry(bytes32)(FundingEntry)

    mapping(bytes32 => mapping(address => Position)) public positions;
    // getter positions(bytes32, address)(Position)

    mapping(bytes32 => mapping(uint => address)) public positionIdToAccount;
    // getter positionIdToAccount(bytes32, uint)(address)

    bytes32 public constant CONTRACT_NAME = "PerpsStorageV2";

    /* ========== MODIFIERS ========== */

    modifier requireInit(bytes32 marketKey) {
        require(marketScalars[marketKey].baseAsset != bytes32(0), "market not initialised");
        _;
    }

    /* ========== CONSTRUCTOR ========== */

    constructor(address _owner, address _associatedContract) public Owned(_owner) State(_associatedContract) {}

    /* ========== EXTERNAL VIEWS ========== */

    /// autogenerated

    /* ========== EXTERNAL STORAGE MUTATIVE (to be refactored) ========== */

    function initMarket(bytes32 marketKey, bytes32 baseAsset) external onlyAssociatedContract {
        // validate input
        require(marketKey != bytes32(0), "market key cannot be empty");
        require(baseAsset != bytes32(0), "asset key cannot be empty");
        // load market
        MarketScalars storage market = marketScalars[marketKey];
        // check is not initialized already (can only be initialized once)
        // (it should be ok to re-initialize if no positions were created yet, but
        // this would only be needed if baseAsset was incorrectly set the first time, so is
        // an edge case that doesn't justify any added side effects concerns for a less strict check)
        require(market.baseAsset == bytes32(0), "already initialized");
        // set asset
        market.baseAsset = baseAsset;
        // event
        emit MarketInitialised(marketKey, baseAsset);
        // initialise the funding with 0 initially accrued
        updateFunding(marketKey, 0);
    }

    function positionWithInit(bytes32 marketKey, address account)
        public
        onlyAssociatedContract
        requireInit(marketKey)
        returns (Position memory)
    {
        // load stored position to initialise or return
        Position storage position = positions[marketKey][account];

        // if position has no id, it wasn't initialized, initialize it:
        if (position.id == 0) {
            // set marketKey, this is useful for methods that operate on Position, to avoid having
            // to pass marketKey separately
            position.marketKey = marketKey;
            // id
            marketScalars[marketKey].lastPositionId++; // increment position id
            // user positions start from 1 to avoid clashing with default empty position
            uint id = marketScalars[marketKey].lastPositionId;
            position.id = id;
            // update owner mapping
            positionIdToAccount[marketKey][id] = account;
            // event
            emit PositionInitialised(marketKey, id, account);
        }

        return position; // returns memory
    }

    function updateFunding(bytes32 marketKey, int funding) public onlyAssociatedContract requireInit(marketKey) {
        lastFundingEntry[marketKey] = FundingEntry(funding, block.timestamp);
        emit FundingUpdated(marketKey, funding, block.timestamp);
    }

    function storePosition(
        bytes32 marketKey,
        address account,
        uint newMargin,
        uint newLocked,
        int newSize,
        uint price
    ) external onlyAssociatedContract requireInit(marketKey) returns (Position memory) {
        // ensure it's initialized, return is ignored because is memory, but storage is needed
        positionWithInit(marketKey, account);
        // load the storage
        Position storage position = positions[marketKey][account];
        // update values according to inputs
        position.margin = newMargin;
        position.lockedMargin = newLocked;
        position.size = newSize;
        position.lastPrice = price;
        // update funding entry to last entry
        position.lastFundingEntry = lastFundingEntry[marketKey];
        return position; // returns memory
    }

    function storeMarketAggregates(
        bytes32 marketKey,
        uint marketSize,
        int marketSkew,
        int entryDebtCorrection
    ) external onlyAssociatedContract requireInit(marketKey) {
        MarketScalars storage market = marketScalars[marketKey];
        market.marketSize = marketSize;
        market.marketSkew = marketSkew;
        market.entryDebtCorrection = entryDebtCorrection;
    }
}
